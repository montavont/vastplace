# Copyright (c) 2012 Institut Mines-Telecom / Telecom Bretagne. All rights reserved.
#
# This file is part of Wi2Me.
#
# Wi2Me is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Wi2Me is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Wi2Me.  If not, see <http://www.gnu.org/licenses/>.
#


# This source modules parses sqlite databases generated by the wi2me android application 

import sqlite3

TYPE_DISCONNECTED = 0
TYPE_CONNECTION_START = 1
TYPE_ASSOCIATING = 2
TYPE_ASSOCIATED = 3
TYPE_CONNECTED = 4
TYPE_DHCP = 5
TYPE_PASSED_PORTAL = 6
TYPE_TIMEOUT = 7
TYPE_RSSI_CHANGE = 8

databaseEventValues = {
	TYPE_DISCONNECTED : "DISCONNECTED",
	TYPE_CONNECTION_START : "CONNECTION_START",
	TYPE_ASSOCIATING : "ASSOCIATING",
	TYPE_ASSOCIATED : "ASSOCIATED",
	TYPE_CONNECTED : "CONNECTED",
	TYPE_TIMEOUT : "TIMEOUT(15000ms)",
	TYPE_DHCP : "OBTAINING_IPADDR",
        TYPE_RSSI_CHANGE : "NOTIMPL",
}

databaseCNEventValues = {
		TYPE_PASSED_PORTAL : "CONNECTED",
	}

class sqlite_parser:
	def __init__(self, path):
		self.path = path
		self.conn = sqlite3.connect(self.path)
		#self.origin = SourceHelper.ORIGIN_ANDROID
		#self.name = SourceHelper.shortName(path)
		self.tags = []

	############################### Time related functions

	#timestamp for the beginning of the mesurements
	def getStartTime(self):
		c = self.conn.cursor()
		retval = int(c.execute('SELECT MIN(timestamp) from Trace').fetchone()[0])
		return retval

	#timestamp for the end of the mesurements
	def getEndTime(self):
		c = self.conn.cursor()
		retval = int(c.execute('SELECT MAX(timestamp) from Trace').fetchone()[0])
		return retval


	#If the database contains multiple occurence where the app was started and stopped
	"""def getSessions(self):
		retval = []
		c = self.conn.cursor()
		sessionStarts = c.execute("select t.timestamp, e.traceId from externalevent e, trace t where event like '%STARTING%' and t.id = e.traceId").fetchall()

		if len(sessionStarts) > 1:
			for ind, sStarts in enumerate(sessionStarts[1:]):
				startTs, startId = sStarts
				previousSessionStop = c.execute("select timestamp from trace where id = " + str(startId -1)).fetchone()[0]

				retval.append((int(sessionStarts[ind][0]), int(previousSessionStop)))
		elif len(sessionStarts) == 1:
			retval.append((self.getStartTime(), self.getEndTime()))

		return retval

	"""

	############################### Geolocalisation related functions
	#minimal and maximal latitude ant longitude in order to delimitate the place the mesurements took place in
	#The expected order is [lat_min, lat_max, long_min, long_max]
	"""def getExtremeCoordinates(self):
		retval = [0, 0, 0, 0]

		c = self.conn.cursor()

		long_min = c.execute('select MIN(longitude) from Trace where longitude NOT IN (0)').fetchone()[0]
		long_max = c.execute('select MAX(longitude) from Trace where longitude NOT IN (0)').fetchone()[0]
		lat_min = c.execute('select MIN(latitude) from Trace where latitude NOT IN (0)').fetchone()[0]
		lat_max = c.execute('select MAX(latitude) from Trace where latitude NOT IN (0)').fetchone()[0]

		if None not in [lat_min, lat_max, long_min, long_max]:
			retval =  [lat_min, lat_max, long_min, long_max]

		return retval

	#Get the total travelled distance in meters
	def getTravelledDistance(self):
		retval = 0

		c = self.conn.cursor()

		#Trajectory with traffic calculation
		GPSRows = c.execute('SELECT longitude, latitude from Trace').fetchall()
		gpsPoints = [] #All positions

		for row in GPSRows:
			if (row[0] * row[1] == 0):
				continue

			longitude = row[0]
			latitude = row[1]

			gpsPoints.append([longitude, latitude])

		if len(gpsPoints) > 1:
			retval = MapHelper.SequentialDist(gpsPoints)

		return retval"""

	#Get the GPS coordinates of points contained in a certain timerange (or all of them)
	def getPoints(self, timeRange=None, noZeros = True):
		if not timeRange:
			timeRange = [self.getStartTime(), self.getEndTime()]

		start, stop = timeRange
		Points = [] 

		c = self.conn.cursor()

		for latitude ,longitude in c.execute('SELECT latitude, longitude from Trace t, ExternalEvent e where t.timestamp between ? and ? and t.id = e.TraceId and e.event = "NEW_LOCATION"', (start, stop)).fetchall():

			if noZeros and latitude * longitude == 0:
				continue

			Points.append((latitude, longitude))

		return Points

	#Get the GPS coordinates of points contained in a certain timerange (or all of them)
	def getGPSLocationEvents(self, noZeros = True):
		Points = [] 

		c = self.conn.cursor()

		for ts, latitude ,longitude in c.execute('SELECT timestamp, latitude, longitude from Trace t, ExternalEvent e where t.id = e.TraceId and e.event = "NEW_LOCATION"').fetchall():

			if noZeros and latitude * longitude == 0:
				continue

			Points.append((ts, latitude, longitude))

		return Points

	############################### Access point discovery related functions

	# get a list of list of scan results (one list for each attempt)
	# This function does not assume grouping by physical APs and will return a list of Networks
	"""def getScanResults(self, gpsRange=None):
		retval = []
		c = self.conn.cursor()

		if gpsRange:
			lat_min, lat_max, long_min, long_max = gpsRange
			ScanRes = c.execute('SELECT id from Trace where type="WIFI_SCAN_RESULT" and longitude between ? and ? and latitude between ? and ?', (long_min, long_max, lat_min, lat_max)).fetchall()
		else:
			ScanRes = c.execute('SELECT id from Trace where type="WIFI_SCAN_RESULT"').fetchall()

		for scanInd, res in enumerate(ScanRes):
			scanRes = []
			for bssid, level, ssid, latitude, longitude, channel, capabilities, timestamp in c.execute('SELECT BSSID, level, ssid, latitude, longitude, channel, capabilities, timestamp from WifiScanResult s, WifiAP a, Trace t where s.TraceId=' + str(res[0]) + " and a.id = s.WifiAPId and t.id = s.TraceId").fetchall():
				scanRes.append(Network(bssid = bssid, ssid=ssid, channel = channel, detections=[Detection(source = "android", GPS = (latitude, longitude), timestamp = timestamp, rssi = level, scanInd = scanInd)], capabilities = capabilities))

			retval.append(scanRes)

		return retval


	#Retrieve list of all APs seen in the trace
	# This Ill-named function does not group by physical APs and will return a list of Networks with detections corresponding to their bssid
	def getApList(self):
		retval = {}
		c = self.conn.cursor()

		for Table in ["WifiScanResult", "WifiConnectionData", "WifiConnectionEvent", "CommunityNetworkConnectionEvent", "WifiPing"]:
			for bssid, level, ssid, latitude, longitude, channel, capabilities, timestamp in c.execute('SELECT BSSID, level, ssid, latitude, longitude, channel, capabilities, timestamp from ' + Table + ' s, WifiAP a, Trace t where a.id = s.WifiAPId and t.id = s.TraceId').fetchall():
				if bssid in retval:
					retval[bssid].detections.append(Detection(source = "android", GPS = (latitude, longitude), timestamp = timestamp, rssi = level))
				else:
					retval[bssid] = Network(bssid = bssid, ssid=ssid, channel = channel, detections=[Detection(source = "android", GPS = (latitude, longitude), timestamp = timestamp, rssi = level)], capabilities = capabilities)

		return retval.values()


	#Return the number of scan attempts
	def countScans(self):
		retval = 0
		c = self.conn.cursor()

		retval += c.execute('SELECT COUNT(id) from Trace where type="WIFI_SCAN_RESULT"').fetchone()[0]

		return retval


	############################### Device Event related functions


	#Get device connectivity events
	def getEvents(self, eventTypes = databaseEventValues.keys()):
		return self.ExtractEventsFromTable(eventTypes, "WifiConnectionEvent", databaseEventValues)

	#Get device community network events
	def getCNEvents(self, eventTypes = databaseCNEventValues.keys()):
		return self.ExtractEventsFromTable(eventTypes, "CommunityNetworkConnectionEvent", databaseCNEventValues)

	def ExtractEventsFromTable(self, eventTypes, Table, Values):
		retval = []
		c = self.conn.cursor()

		for event in eventTypes:
			for timestamp, bssid, level, ssid, latitude, longitude, channel, capabilities in c.execute('SELECT timestamp, BSSID, level, ssid, latitude, longitude, channel, capabilities from ' + Table + ' e, WifiAP a, Trace t where e.TraceId=t.id and a.id=e.WifiAPId and e.event="' + Values[event] + '"').fetchall():
				network = Network(bssid = bssid, ssid=ssid, channel = channel, detections=[Detection(source = "android", GPS = (latitude, longitude), timestamp = timestamp, rssi = level)], capabilities = capabilities)
				retval.append(ConnectionEvent(state = event, timestamp = timestamp, network = network))

		retval = sorted(retval, key = lambda x : x.timestamp)

		return retval

	############################### Transmitted Data related functions

	#Get a list of the data transfer events, with the associated AP
	def getTransferredData(self):
		retval = []
		c = self.conn.cursor()

		for timestamp, bssid, level, ssid, latitude, longitude, channel, capabilities, bytesTransferred, totalBytes, direction in c.execute('SELECT timestamp, BSSID, level, ssid, latitude, longitude, channel, capabilities, bytesTransferred, totalBytes, d.type from WifiConnectionData d, WifiAP a, Trace t where t.type="WIFI_CONNECTION_DATA" and d.TraceId=t.id and a.id=d.WifiAPId and t.id=d.TraceId').fetchall():
			network = Network(bssid = bssid, ssid=ssid, channel = channel, detections=[Detection(source = "android", GPS = (latitude, longitude), timestamp = timestamp, rssi = level)], capabilities = capabilities)
			retval.append(TransferredData(network, bytesTransferred, totalBytes, LINK_WIFI, direction))

		return retval

        def getTotalTransferredBytes(self, maxts = -1):
            retval = 0

	    c = self.conn.cursor()
	    for timestamp, bssid, level, ssid, latitude, longitude, channel, capabilities, bytesTransferred, totalBytes, direction in c.execute('SELECT timestamp, BSSID, level, ssid, latitude, longitude, channel, capabilities, bytesTransferred, totalBytes, d.type from WifiConnectionData d, WifiAP a, Trace t where t.type="WIFI_CONNECTION_DATA" and d.TraceId=t.id and a.id=d.WifiAPId and t.id=d.TraceId').fetchall():
                retval = totalBytes


            return retval"""
